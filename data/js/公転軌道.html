<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html> <head>
<meta charset="utf-8"  /><!--"euc-jp,Shift_JIS"-->


<link rel="stylesheet" type="text/css">
<title>公転軌道</title>

<script type="text/javascript">

<!--
function openwin(url){

	window.open(url,"","screen.availWidth,screen.availHeight,scrollbars=yes, resizable = yes ,directories = 0");

}
// -->
</script>



<style type="text/css">
a:link { color: #0000ff; }
a:visited { color: #000080; }
a:hover { color: #ff0000; text-decoration: underline; }
a:active { color: #ff8000; }

html,body {
font-family:"ヒラギノ角ゴ Pro W3",メイリオ,Osaka,Arial,Verdana
,"ＭＳ Ｐゴシック",sans-serif;
margin: auto;
overflow-y: auto;
-ms-touch-action: none; /* IE10で、スクロールをとめて、タッチ可能にする。*/
}

body{
text-align : center;
margin: 0 ;
}

 
  
/* --- ボックス --- */
div.section {
padding:5px; /* ボックスの下パディング */
margin: 0 ;
background: #fcffff no-repeat bottom; /* ボックスの背景 */
font-size: 42pt;
color: #000000;
}

div.sousa {
padding:5px; /* ボックスの下パディング */
margin: 0 ;
background: #66cccc no-repeat bottom; /* ボックスの背景 */
font-size: 25pt;
color: #000000;
}

#canvas{
            border: 10px solid #84c1ff;
            cursor:move;
font-size: 10pt;
width: 970px;    
margin: 0 ;
 text-align : center;
}


div.link {
padding:2px; /* ボックスの下パディング */
margin: 0;
background: #e6e6fa no-repeat bottom; /* ボックスの背景 */
font-size: 35pt;
text-align : center;


}


/*div.close {
padding:4px; /* ボックスの下パディング */
text-align : center;
background: #e6e6fa no-repeat bottom; /* ボックスの背景 */
font-size: 25pt;
}   */

</style>
<!--[if lt IE 9]><script src="data/js/excanvas.js"></script><![endif]-->
<script type="text/javascript" src="data/js/processing.js"></script>
<script type="text/javascript" src="data/js/init.js"></script>
<script>
         window.onload = function(){
           // canvas要素
           var canvas = document.getElementsByTagName('canvas')[0];
           // Proccessingのコードが書かれたscript要素
           var codeElm = document.getElementById('processing-code');
           // 上記要素の内容を取得
           var code = codeElm.textContent || codeElm.innerText;


           new Processing(canvas, code);
         };
       </script>
       <script id="processing-code" type="text/processing" data-processing-target="canvas">


float rotX, rotY;
float dru;
int NUM; 
int cc1;
float t; //角度
 int rsui; //円の半径
int rkin; //円の半径
int rti; //円の半径
int rka; //円の半径
int rmoku; //円の半径
int rcere;
Botan1 bt1; 
float sX;
float sY;

//速度調整用
int rectX, rectY;     
int rect2X, rect2Y;  
int rect3X, rect3Y;  
int rectSize = 90;     
int rect2Size = 90;
int rect3Size = 90;
color rectColor, rect2Color, rect3Color, baseColor;
color rectHighlight, rect2Highlight, rect3Highlight;
color currentColor;
boolean rectOver = false;
boolean rect2Over = false;
boolean rect3Over = false;


void setup(){
  size(970, 600, OPENGL);    //OPENGLと書くことによって、3D空間であることを明示する
hint(ENABLE_OPENGL_4X_SMOOTH); //DISABLE_OPENGL_2X_SMOOTHでも可

NUM = 1;
cc1 = 0;
 tsui = 0;
 tkin = 0;
 tti = 0;
 tka = 0;
 tmoku = 0;
 tdo = 0;
 tten = 0;
 tkai = 0;
 tmei = 0;
 thare = 0;
 tcere = 0;
  rsui = 20;
  rkin = 40;
  rti = 60;
  rka = 120;
  rmoku = 400;
  rdo = 750;
  rten = 1300;
  rkai = 2000;
  rmei = 2400;
  rhare =1150;
  rcere = 200;

  t = 0.12;
 


rectColor = color(10,200,250);
  rectHighlight = color(10,100,200);
  rect2Color = color(10,250,150);
  rect2Highlight = color(10,150,50);
  rect3Color = color(250,250,25);
  rect3Highlight = color(150,150,25);

  baseColor = color(100);
  currentColor = baseColor;
  rectX = width*0.93-rectSize/2;
  rectY = height*0.4;
  rect2X = width*0.93-rectSize/2;
  rect2Y = height*0.4+rectSize*1.2;
  rect3X = width*0.93-rectSize/2;
  rect3Y = height*0.4+2*rectSize*1.2;


}

void draw(){
background(#1c1c1c);  
smooth(); 



 if (mousePressed) {
 dru = rotX;
}



 update(mouseX, mouseY);
 if (rectOver) {
    fill(rectHighlight);
  t=0.12;
} else {
    fill(rectColor);  
}
  stroke(0);
  
rect(rectX, rectY, rectSize, rectSize);
  
  if (rect2Over) {
    fill(rect2Highlight);
t=1.416
  } else {
    fill(rect2Color);
}
  stroke(0);
  rect(rect2X, rect2Y, rect2Size, rect2Size);

  if (rect3Over) {
    fill(rect3Highlight);
t=29.7
  } else {
    fill(rect3Color);

}
  stroke(0);
  rect(rect3X, rect3Y, rect3Size, rect3Size);

pushMatrix();
translate(width/2, height/2);    //立体の中心を画面中央に移動   

   tsui += t/0.24;
   tkin += t/0.61;
   tti += t/1;
   tka += t/1.88;
   tmoku += t/11.8;
   tdo += t/29.4;
   tten += t/84;
   tkai += t/164.7;
   tmei += t/247.7;
   thare += t/76.1
   tcere += t/4.4


scale(2-1.9*dru/970);

//太陽
fill(255,255,0);
noStroke();
  ellipse(0,0,10,10);


//水星
   x = rsui*cos(tsui);
   y = rsui*sin(tsui);
noFill();
stroke(255);
  ellipse(0,0,40,40);

  noStroke();
fill(155,155,155);
  ellipse(-rsui*cos(tsui)+0,rsui*sin(tsui)+0,6,6);



//金星
  noFill();
stroke(255);
  ellipse(0,0,80,80);

  noStroke();
fill(250,210,50);
  ellipse(-rkin*cos(tkin),rkin*sin(tkin),10,10);


//地球
  noFill();
stroke(255);
  ellipse(0,0,120,120);

  noStroke();
fill(10,250,200);
  ellipse(-rti*cos(tti),rti*sin(tti),10,10);


//火星
  noFill();
stroke(255);
  ellipse(0,0,240,240);

  noStroke();
fill(255,50,0);
  ellipse(-rka*cos(tka),rka*sin(tka),10,10);


//木星
  noFill();
stroke(255);
  ellipse(0,0,800,800);

  noStroke();
fill(150,50,50);
  ellipse(-rmoku*cos(tmoku),rmoku*sin(tmoku),200,200);

//土星
  noFill();
stroke(255);
  ellipse(0,0,1500,1500);

  noStroke();
fill(200,200,50);
  ellipse(-rdo*cos(tdo),rdo*sin(tdo),160,160);

//天王星
  noFill();
stroke(255);
  ellipse(0,0,2600,2600);

  noStroke();
fill(120,200,150);
  ellipse(-rten*cos(tten),rten*sin(tten),90,90);

//海王星
  noFill();
stroke(255);
  ellipse(0,0,4000,4000);

  noStroke();
fill(20,50,255);
  ellipse(-rkai*cos(tkai),rkai*sin(tkai),90,90);

//冥王星
  noFill();
stroke(255);
  ellipse(400,-400,4800,4800);

  noStroke();
fill(#1c1c1c);
  rect(-rmei*cos(tmei)+375,rmei*sin(tmei)-425,50,50);
fill(120,120,25);
  rect(-rmei*cos(tmei)+350,rmei*sin(tmei)-450,100,100);


//彗星

//彗星中点
sA = rhare*cos(thare)-1100; 
sB = 400*sin(thare)-0;


int harer = 70;
int hareg = 150;
int hareb = 255;
int hareal = 255;
hi = 0;
pushMatrix();
  noFill();
stroke(255);
rotate(PI/3.2);
  ellipse(-1100,-0,2300,800);
fill(255);
  ellipse(sA,sB,5,5);

  noStroke();


for (i=0;i<20;i=i+1){
fill(harer,hareg,hareb,hareal);
//尾の終点

float sX = sA+(hi*(sA)/sqrt(sq(sB)+sq(sA)));
float sY = sB+(hi*(sB)/sqrt(sq(sA)+sq(sB)));

beginShape(); 
vertex(sA,sB); 
vertex(((sX-sA)*cos(PI/36)-(sY-sB)*sin(PI/36))+sA,((sX-sA)*sin(PI/36)+(sY-sB)*cos(PI/36))+sB);
vertex(sX,sY); 
vertex(((sX-sA)*cos(71*PI/36)-(sY-sB)*sin(71*PI/36))+sA,((sX-sA)*sin(71*PI/36)+(sY-sB)*cos(71*PI/36))+sB);
endShape(); 

hi = hi+15;
harer = harer-4;
hareg = hareg-6;
hareb = hareb-10;
hareal = hareal-5;
}

fill(70,150,255);
  ellipse(sA,sB,10,10);
popMatrix();

//小惑星帯ケレス

  noFill();
stroke(250,250,0);
  ellipse(0,0,400,400);

  noStroke();
fill(30,30,140,180);
  rect(-rcere*cos(tcere)-4,rcere*sin(tcere)-4,8,8);
fill(200,200,200);
  rect(-rcere*cos(tcere)-8,rcere*sin(tcere)-8,16,16);

fill(#1c1c1c);
ellipse(0,0,300,300);

fill(30,30,140,180);
ellipse(0,0,600,600);
popMatrix();



}


void update(int x, int y) {
  if ( overRect2(rect2X, rect2Y, rect2Size,rect2Size) ) {
    rect2Over = true;
    rectOver = false;
    rect3Over = false;
 
} else if ( overRect(rectX, rectY, rectSize, rectSize) ) {
    rectOver = true;
    rect2Over = false;
    rect3Over = false;

  }else if ( overRect3(rect3X, rect3Y, rect3Size, rect3Size) ) {
    rect3Over = true;
    rect2Over = false;
    rectOver = false;

  }
}

void mousePressed() {
  if (rect2Over) {
    currentColor = rect2Color;
  }
  if (rectOver) {
    currentColor = rectColor;
 }
  if (rect3Over) {
    currentColor = rect3Color;
 }

}

boolean overRect(int x, int y, int width, int height)  {
  if (mouseX >= x && mouseX <= x+width && 
      mouseY >= y && mouseY <= y+height) {
    return true;
  } else {
    return false;
  }
}
boolean overRect2(int x, int y, int width, int height)  {
  if (mouseX >= x && mouseX <= x+width && 
      mouseY >= y && mouseY <= y+height) {
    return true;
  } else {
    return false;
  }
}

boolean overRect3(int x, int y, int width, int height)  {
  if (mouseX >= x && mouseX <= x+width && 
      mouseY >= y && mouseY <= y+height) {
    return true;
  } else {
    return false;
  }
}




// マウスドラッグ時の処理
void mouseDragged(){
  rotX += (mouseX - pmouseX) * 1;
  rotY -= (mouseY - pmouseY) * 0.01;

    if(rotX>1 && rotX<970 ){
      rotX += (mouseX - pmouseX) * 1;
}
   else if(2-1.9*dru/970 >= 1.9){
    rotX = 0;
}
   else if(2-1.9*dru/970 <= 0.4){
    rotX = 970;
}

}


</script>
    </head>
    <body bgcolor="#20b2aa" ontouchmove="event.preventDefault()">



<div class="section" id= "section">

<center>公転軌道</center>
</div>  

<div class="sousa">

<center>画面を指で左右にスワイプして太陽系を拡大・縮小してみましょう</center>
</div>  



<div class="canvasContainer"  >
	<canvas   id="canvas"></canvas>
<p>Implement by <a href="http://processingjs.org/" target="_blank">Processing.js</a>
</div>





</body>  
</html>

